/*
 * Copyright (C) 2006-2020 T. Zoerner.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#define PY_SSIZE_T_CLEAN
#include "Python.h"

#include <libzvbi.h>

#include "zvbi_proxy.h"

typedef struct {
    vbi_proxy_client * ctx;
    //SV *            proxy_cb;
    //SV *            proxy_user_data;
} ZvbiProxyObj;

static PyObject * ZvbiProxyError;

#if 0
/*
 * Invoke callback for an event generated by the proxy client
 */
static void
zvbi_xs_proxy_callback( void * user_data, VBI_PROXY_EV_TYPE ev_mask )
{
        VbiProxyObj * ctx = user_data;

        if ((ctx != NULL) && (ctx->proxy_cb != NULL)) {
                dSP ;
                ENTER ;
                SAVETMPS ;

                /* push the function parameters on the Perl interpreter stack */
                PUSHMARK(SP) ;
                XPUSHs(sv_2mortal(newSViv(ev_mask)));
                if (ctx->proxy_user_data != NULL) {
                        XPUSHs(ctx->proxy_user_data);
                }
                PUTBACK ;

                /* invoke the Perl subroutine */
                call_sv(ctx->proxy_cb, G_VOID | G_DISCARD) ;

                FREETMPS ;
                LEAVE ;
        }
}
#endif

// ---------------------------------------------------------------------------
//  VBI Proxy Client
// ---------------------------------------------------------------------------

static PyObject *
ZvbiProxy_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    ZvbiProxyObj *self;
    self = (ZvbiProxyObj *) type->tp_alloc(type, 0);

    return (PyObject *) self;
}

static void
ZvbiProxy_dealloc(ZvbiProxyObj *self)
{
    if (self->ctx) {
        vbi_proxy_client_destroy(self->ctx);
        //TODO Save_SvREFCNT_dec(vpc->proxy_cb);
        //TODO Save_SvREFCNT_dec(vpc->proxy_user_data);
    }
    Py_TYPE(self)->tp_free((PyObject *) self);
}

static int
ZvbiProxy_init(ZvbiProxyObj *self, PyObject *args, PyObject *kwds)
{
    static char * kwlist[] = {"dev",
                              "appname",
                              "appflags",
                              "trace",
                              NULL};
    char *dev_name = NULL;
    const char *p_client_name = NULL;
    int client_flags = 0;
    int trace_level = 0;
    char * errorstr = NULL;

    // reset state in case the module is already initialized
    if (self->ctx) {
        vbi_proxy_client_destroy(self->ctx);
        self->ctx = NULL;
    }

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "ss|ii", kwlist,
                                     &dev_name, &p_client_name,
                                     &client_flags, &trace_level))
    {
        return -1;
    }

    self->ctx = vbi_proxy_client_create(dev_name, p_client_name, client_flags,
                                        &errorstr, trace_level);

    if (self->ctx == NULL) {
        PyErr_SetString(ZvbiProxyError, errorstr ? errorstr : "unknown error");
        return -1;
    }
    return 0;
}


// This function is currently NOT supported because we must not create a 2nd
// reference to the C object (i.e. on Perl level there are two separate objects
// but both share the same object on C level; so we'd have to implement a
// secondary reference counter on C level.) It's not worth the effort anyway
// since the application must have received the capture reference.
//

#if 0
VbiCaptureObj *
vbi_proxy_client_get_capture_if(vpc)
        VbiProxyObj * vpc
#endif

#if 0

void
vbi_proxy_client_set_callback(vpc, callback=NULL, user_data=NULL)
        VbiProxyObj * vpc
        CV * callback
        SV * user_data
        CODE:
        Save_SvREFCNT_dec(vpc->proxy_cb);
        Save_SvREFCNT_dec(vpc->proxy_user_data);
        if (callback != NULL) {
                vpc->proxy_cb = SvREFCNT_inc(callback);
                vpc->proxy_user_data = SvREFCNT_inc(user_data);
                vbi_proxy_client_set_callback(vpc->ctx, zvbi_xs_proxy_callback, vpc);
        } else {
                vbi_proxy_client_set_callback(vpc->ctx, NULL, NULL);
        }

int
vbi_proxy_client_get_driver_api(vpc)
        VbiProxyObj * vpc
        CODE:
        RETVAL = vbi_proxy_client_get_driver_api(vpc->ctx);
        OUTPUT:
        RETVAL

int
vbi_proxy_client_channel_request(vpc, chn_prio, profile=NULL)
        VbiProxyObj * vpc
        VBI_CHN_PRIO chn_prio
        HV * profile
        PREINIT:
        vbi_channel_profile l_profile;
        SV ** p_sv;
        CODE:
        Zero(&l_profile, 1, vbi_channel_profile);
        if (profile != NULL) {
                if (NULL != (p_sv = hv_fetch_pv(profile, sub_prio))) {
                        l_profile.sub_prio = SvIV (*p_sv);
                }
                if (NULL != (p_sv = hv_fetch_pv(profile, allow_suspend))) {
                        l_profile.allow_suspend = SvIV (*p_sv);
                }
                if (NULL != (p_sv = hv_fetch_pv(profile, min_duration))) {
                        l_profile.min_duration = SvIV (*p_sv);
                }
                if (NULL != (p_sv = hv_fetch_pv(profile, exp_duration))) {
                        l_profile.exp_duration = SvIV (*p_sv);
                }
                l_profile.is_valid = TRUE;
        }
        RETVAL = vbi_proxy_client_channel_request(vpc->ctx, chn_prio, &l_profile);
        OUTPUT:
        RETVAL

int
vbi_proxy_client_channel_notify(vpc, notify_flags, scanning=0)
        VbiProxyObj * vpc
        int notify_flags
        int scanning
        CODE:
        RETVAL = vbi_proxy_client_channel_notify(vpc->ctx, notify_flags, scanning);
        OUTPUT:
        RETVAL

int
vbi_proxy_client_channel_suspend(vpc, cmd)
        VbiProxyObj * vpc
        int cmd
        CODE:
        RETVAL = vbi_proxy_client_channel_suspend(vpc->ctx, cmd);
        OUTPUT:
        RETVAL

int
vbi_proxy_client_device_ioctl(vpc, request, sv_buf)
        VbiProxyObj * vpc
        int request
        SV * sv_buf
        PREINIT:
        char * p_buf;
        STRLEN buf_size;
        CODE:
        if (SvOK(sv_buf)) {
                p_buf = (void *) SvPV(sv_buf, buf_size);
                RETVAL = vbi_proxy_client_device_ioctl(vpc->ctx, request, p_buf);
        } else {
                croak("Argument buffer is undefined or not a scalar");
        }
        OUTPUT:
        RETVAL

void
vbi_proxy_client_get_channel_desc(vpc)
        VbiProxyObj * vpc
        PREINIT:
        unsigned int scanning;
        vbi_bool granted;
        PPCODE:
        if (vbi_proxy_client_get_channel_desc(vpc->ctx, &scanning, &granted) == 0) {
                EXTEND(sp,2);
                PUSHs (sv_2mortal (newSVuv (scanning)));
                PUSHs (sv_2mortal (newSViv (granted)));
        }

vbi_bool
vbi_proxy_client_has_channel_control(vpc)
        VbiProxyObj * vpc
        CODE:
        RETVAL = vbi_proxy_client_has_channel_control(vpc->ctx);
        OUTPUT:
        RETVAL

#endif // 0

// ---------------------------------------------------------------------------

vbi_proxy_client *
ZvbiProxy_GetCtx(PyObject * self)
{
    return ((ZvbiProxyObj*)self)->ctx;
}

static PyMethodDef ZvbiProxy_MethodsDef[] =
{
    //{"query",     (PyCFunction) Quota_query,     METH_VARARGS | METH_KEYWORDS, Quota_query__doc__ },
    {NULL}  /* Sentinel */
};

PyTypeObject ZvbiProxyTypeDef =
{
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "Zvbi.Proxy",
    .tp_doc = PyDoc_STR("Class connecting to proxy daemon for sharing a capture device"),
    .tp_basicsize = sizeof(ZvbiProxyObj),
    .tp_itemsize = 0,
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    .tp_new = ZvbiProxy_new,
    .tp_init = (initproc) ZvbiProxy_init,
    .tp_dealloc = (destructor) ZvbiProxy_dealloc,
    //.tp_repr = (PyObject * (*)(PyObject*)) ZvbiProxy_Repr,
    .tp_methods = ZvbiProxy_MethodsDef,
    //.tp_members = ZvbiProxy_Members,
};

int PyInit_Proxy(PyObject * module, PyObject * error_base)
{
    if (PyType_Ready(&ZvbiProxyTypeDef) < 0) {
        return -1;
    }

    // create exception class
    ZvbiProxyError = PyErr_NewException("Zvbi.ProxyError", error_base, NULL);
    Py_XINCREF(ZvbiProxyError);
    if (PyModule_AddObject(module, "ProxyError", ZvbiProxyError) < 0) {
        Py_XDECREF(ZvbiProxyError);
        Py_CLEAR(ZvbiProxyError);
        Py_DECREF(module);
        return -1;
    }

    // create class type object
    Py_INCREF(&ZvbiProxyTypeDef);
    if (PyModule_AddObject(module, "Proxy", (PyObject *) &ZvbiProxyTypeDef) < 0) {
        Py_DECREF(&ZvbiProxyTypeDef);
        Py_XDECREF(ZvbiProxyError);
        Py_CLEAR(ZvbiProxyError);
        return -1;
    }

    return 0;
}
